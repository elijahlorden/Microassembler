
config {
	ControlWordWidth 24 #Width of control word
	BankMask 1 #Portion of the control word reserved for the bank selector (starts at lsb)
	MicroprogramLength 4096 #Maximum number of microinstructions
	OpWidth 8 #Width of opcode
}

#micromachine actions
const mi_action_default				0
const mi_action_next				1
const mi_action_execute				2
const mi_action_branch				3
const mi_action_call				4
const mi_action_return				5
const mi_action_halt				6
const mi_action_reset				7

#branch types
const branch_unconditional			0
const branch_zero					1
const branch_less_than_zero			2
const branch_greater_than_zero		3
const branch_greater_than_or_zero	4
const branch_less_than_or_zero		5
const branch_carry					6
const branch_overflow				7


#bank 0
control mi_action					1 2:0 	#define a control called 'mi_action' on bank 0 at 4:2
control mi_branchtype				1 5:3
control mi_branchtype_invert		1 6 	#define a control called 'mi_branchtype_invert' on bank 0 at 8
control mi_jumpaddr					1 21:10

entrypoints { #Define fetch cycle, instruction and interrupt entrypoints
	fetch: TestSequence,
	interrupt: sequence3,
	0: sequence,
}

empty { #Empty assertion used to fill empty space
	mi_action: mi_action_reset
}

sequence TestSequence {
	::label1:: #set a label on the next microinstruction
	assert {
		mi_action: 1, #set a control signal to a literal number
	}
	assert {
		mi_action: mi_action_branch, #set a control signal to a constant
		mi_branchtype: branch_zero,
		mi_jumpaddr: sequence2, #set a control signal to the address of another sequence
	}
	::label2::
	testmacro(branch_zero, label1) #Reference a macro (expanded in pre-link stage)
	testmacro(label1, branch_zero)
	::label3::
	assert {
		mi_jumpaddr: _testmacro_0.mlabel1, #set a control signal to the address of a label
	}
}

sequence sequence2 {
	::label1::
	assert {
		mi_action: 5
	}
	::label2::
	testmacro(0, 0)
}

sequence sequence3 {
	::label1::
	assert {
		mi_action: 5
	}
}

macro testmacro(param1, param2) { #Macros can accept compile-time parameters
	::mlabel1::
	assert { mi_action: param2, mi_branchtype: param1, mi_jumpaddr: mlabel1 }
	::mlabel2::
	testmacro2(param1, param2)
	assert{}
	::label3::
}

macro testmacro2(param2, param3) {
	assert { mi_action: end }
	::end::
}