
config {
	ControlWordWidth 32 #Width of control word
	BankMask 1 #Portion of the control word reserved for the bank selector (starts at lsb)
	MicroprogramLength 4096 #Maximum number of microinstructions
	OpWidth 8 #Width of opcode
}

#micromachine actions
const mi_action_default				0
const mi_action_next				1
const mi_action_execute				2
const mi_action_branch				3
const mi_action_call				4
const mi_action_return				5
const mi_action_halt				6
const mi_action_reset				7

#branch types
const branch_unconditional			0
const branch_zero					1
const branch_less_than_zero			2
const branch_greater_than_zero		3
const branch_greater_than_or_zero	4
const branch_less_than_or_zero		5
const branch_carry					6
const branch_overflow				7


#bank 0
control mi_action					0 2:0	#Alters behavior of the micromachine
control mi_branchtype				0 5:3	#Micromachine branch type
control mi_branchtype_invert		0 6		#Inverts the meaning of the micromachine branch type (ex. branch if zero -> branch if not zero)
control mi_jumpaddr					0 29:18	#Micromachine branch address

#bank 1
control rt_src						1 4:0	#Source address for register transfer
control rt_dst						1 13:5	#Destination address for register transfer
control register_transfer			1 10	#Perform register transfer
control aluop						1 15:11	#ALU operation to perform
control stackop						1 18:16 #Stack operation to perform
#!CANNOT BE USED WITH PREVIOUS BANK 1 OPERATIONS!
control rload						1 29	#Loads half of a register with an inline value
control rload_dst					1 4:0	#Destination of register load
control rload_val					1 28:5	#Value of register load

entrypoints { #Define fetch cycle, instruction and interrupt entrypoints
	fetch: FetchSequence,
	interrupt: InterruptSequence,
	0: Test #Test.  Since the fetch sequence is left empty, the Test sequence should be placed at address zero and executed at startup
}

empty { #Assertion used to fill empty space, in this case executing empty space results in a machine reset
	mi_action: mi_action_reset
}

sequence FetchSequence {
	
}

sequence InterruptSequence {
	
}

sequence Test {
	Load_48(3, 0xF00000F00000)
	Transfer(3, 1)
	Transfer(1, 2)
}

macro Load_24(address, value) {
	assert {
		rload: 1,
		rload_dst: address,
		rload_val: value
	}
}

macro Load_48(address, value) {
	Load_24(address, value[23:0])
	Load_24(0, value[47:24])
}

macro Transfer(src, dst) {
	assert {
		register_transfer: 1,
		rt_src: src,
		rt_dst: dst
	}
}